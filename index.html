<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ギター／ベースピアノ変換サイト</title>
<style>
:root{
  --bg0:#050505;
  --bg1:#0a0a0a;

  --panel: rgba(10,10,10,.58);
  --shadow: 0 12px 34px rgba(0,0,0,.58);
  --glow: 0 0 10px rgba(255,255,255,.45), 0 0 22px rgba(255,255,255,.25);
  --glowStrong: 0 0 12px rgba(255,255,255,.70), 0 0 30px rgba(255,255,255,.40);

  /* fretboard */
  --cellW: 40px;
  --cellH: 34px;
  --fretW: 46px;
  --spacerH: 34px; /* gap between 0 and 1 */

  /* piano */
  --pW: 190px;
  --stepH: 14px;
  --whiteH: 14px;
  --blackH: 11px;
  --blackW: 132px;

  /* X buttons */
  --xW: 58px;

  --radius: 18px;
}

*{ box-sizing:border-box; }
html, body{ height:100%; }
body{
  margin:0;
  color:#f4f4f4;
  font-family: system-ui, "Segoe UI", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
  background:
    radial-gradient(1100px 520px at 65% 18%, rgba(255,255,255,.10), transparent 62%),
    radial-gradient(900px 680px at 25% 72%, rgba(255,255,255,.06), transparent 60%),
    linear-gradient(90deg, var(--bg0), var(--bg1) 55%, rgba(255,255,255,.06) 100%);
}
body::before{
  content:"";
  position:fixed;
  inset:0;
  pointer-events:none;
  background:
    repeating-linear-gradient(0deg, rgba(255,255,255,.03) 0 1px, transparent 1px 4px),
    repeating-linear-gradient(90deg, rgba(255,255,255,.02) 0 1px, transparent 1px 4px);
  mix-blend-mode: overlay;
  opacity:.25;
}

.wrap{ max-width: 1440px; margin: 0 auto; padding: 14px; }

.header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
  margin-bottom:10px;
}
h1{
  margin:0;
  font-size:22px;
  font-weight:1000;
  letter-spacing:.5px;
  text-shadow: var(--glow);
}
.controls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}
select, .btn, input, label{
  border:1px solid rgba(255,255,255,.30);
  background: rgba(10,10,10,.55);
  color:#fff;
  padding:10px 12px;
  border-radius:14px;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
  outline:none;
}
input{ cursor:text; }
select:hover, .btn:hover, input:hover, label:hover{
  border-color: rgba(255,255,255,.58);
  box-shadow: var(--glow);
}
.btn:active{ transform: translateY(1px); }

.toggle{
  display:flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.30);
  background: rgba(10,10,10,.55);
  user-select:none;
}
.toggle input{ width:18px; height:18px; cursor:pointer; }

.main{ display:flex; gap:14px; align-items:flex-start; flex-wrap:nowrap; overflow-x:auto; padding-bottom:8px; }
.main::-webkit-scrollbar{ height:10px; }
.main::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.22);
  border-radius:999px;
  border:2px solid rgba(0,0,0,.55);
}

.panel{
  border-radius:var(--radius);
  background: var(--panel);
  border:1px solid rgba(255,255,255,.20);
  box-shadow: var(--shadow);
  overflow:hidden;
  backdrop-filter: blur(8px);
}
.panel-title{
  padding:10px 12px;
  font-weight:1000;
  letter-spacing:.3px;
  font-size:15px;
  border-bottom: 1px solid rgba(255,255,255,.14);
  background: linear-gradient(90deg, rgba(255,255,255,.10), rgba(0,0,0,0));
}
.panel-body{ padding:12px; }

.fret-piano{ display:flex; gap:12px; align-items:flex-start; }

/* mute strip (dots summary) */
.mute-strip{ display:flex; align-items:center; gap:8px; margin: 0 0 10px 0; }
.mute-x{
  width:18px; text-align:center; font-weight:1000; text-shadow: var(--glow);
  border-radius:10px;
  padding:4px 6px;
}
.mute-x.glow{
  box-shadow: 0 0 16px rgba(255,255,255,.50);
  border:1px solid rgba(255,255,255,.35);
  background: rgba(255,255,255,.08);
}
.dot{
  width:14px; height:14px; border-radius:50%;
  background: rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.18);
  box-shadow: inset 0 0 10px rgba(0,0,0,.65);
}
.dot.on{ background: rgba(255,255,255,.95); border-color: rgba(255,255,255,.90); box-shadow: var(--glowStrong); }
.dot.mutedGlow{
  background: rgba(255,255,255,.16);
  border-color: rgba(255,255,255,.35);
  box-shadow: 0 0 16px rgba(255,255,255,.40);
}

/* header: strings + X buttons */
.headerwrap{
  display:flex;
  gap:10px;
  align-items:stretch;
}
.strings-row{
  display:grid;
  grid-template-columns: var(--fretW) repeat(6, var(--cellW));
  gap:8px 0;
  align-items:stretch;
  margin-bottom:8px;
}
.slabwrap{
  border:1px solid rgba(255,255,255,.14);
  border-radius:12px;
  background: rgba(0,0,0,.35);
  padding:6px 0 7px 0;
  text-align:center;
}
.openname{ font-weight:1000; font-size:12px; color: rgba(255,255,255,.92); line-height:1; text-shadow: 0 0 10px rgba(255,255,255,.15); }
.slab{ margin-top:4px; font-weight:1000; font-size:13px; color: rgba(255,255,255,.92); line-height:1; }
.slabwrap.disabled{ opacity:.25; }
.slabwrap.muted{ opacity:.40; background: rgba(255,255,255,.06); }
.slabwrap.mutedGlow{ opacity:.55; box-shadow: 0 0 18px rgba(255,255,255,.40); border-color: rgba(255,255,255,.40); }

/* per-string mute X buttons (outside fretboard) */
.xcol{
  width: var(--xW);
  display:flex;
  flex-direction:column;
  gap:8px;
}
.xbtn{
  width: var(--xW);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.22);
  background: rgba(0,0,0,.35);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:8px 0 10px;
  cursor:pointer;
  user-select:none;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12);
  transition: box-shadow .18s ease, border-color .18s ease, transform .06s ease;
  touch-action: manipulation;
}
.xbtn .x{
  font-size:18px;
  font-weight:1000;
  line-height:1;
}
.xbtn .lbl{
  margin-top:6px;
  font-size:12px;
  font-weight:1000;
  opacity:.9;
}
.xbtn:hover{
  border-color: rgba(255,255,255,.55);
  box-shadow: var(--glow);
}
.xbtn:active{ transform: translateY(1px); }
.xbtn.on{
  border-color: rgba(255,255,255,.70);
  box-shadow: var(--glowStrong);
  background: rgba(255,255,255,.12);
}
.xbtn.disabled{
  opacity:.20;
  pointer-events:none;
}

/* scroll */
.scroll{
  max-height: 78vh;
  overflow:auto;
  padding-right:6px;
}
.scroll::-webkit-scrollbar{ width:10px; }
.scroll::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.22);
  border-radius:999px;
  border:2px solid rgba(0,0,0,.55);
}
.scroll::-webkit-scrollbar-track{ background: rgba(0,0,0,.35); border-radius:999px; }

/* board + sticky X column */
.fretwrap{
  display:flex;
  gap:10px;
  align-items:flex-start;
}
.board{
  display:grid;
  grid-template-columns: var(--fretW) repeat(6, var(--cellW));
  grid-auto-rows: var(--cellH);
  gap:0;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.22);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.20),
    inset 0 -1px 0 rgba(0,0,0,.80),
    0 0 18px rgba(255,255,255,.08);
  background: rgba(0,0,0,.25);
}

/* sticky xcol inside scroll (keeps visible while scrolling frets) */
.xcol-sticky{
  position: sticky;
  top: 0;
  align-self:flex-start;
  padding-top: 0;
}

.fret{
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:1000;
  font-size:13px;
  color: rgba(255,255,255,.92);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(0,0,0,.45));
  border-right:1px solid rgba(255,255,255,.18);
  border-bottom:1px solid rgba(255,255,255,.10);
  text-shadow: 0 0 10px rgba(255,255,255,.22);
}
.fret.openrow{
  background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(0,0,0,.38));
}
.cell{
  cursor:pointer;
  user-select:none;
  position:relative;
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.42));
  border-right:1px solid rgba(255,255,255,.18);
  border-bottom:1px solid rgba(255,255,255,.10);
  transition: background .12s ease, box-shadow .12s ease;
  touch-action: manipulation; /* reduce double-tap zoom */
}
.cell::before{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -1px 0 rgba(0,0,0,.75);
  opacity:.9;
}
.cell:hover{ background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(0,0,0,.38)); }
.cell.selected{
  background: linear-gradient(180deg, rgba(255,255,255,.38), rgba(0,0,0,.25));
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.35), var(--glowStrong);
}
.cell.disabled{ opacity:.18; pointer-events:none; filter: grayscale(1); }

.cell.openrow{ background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(0,0,0,.36)); }
.cell.openrow:hover{ background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(0,0,0,.34)); }

.cell.mutedcol{ opacity:.28; background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(0,0,0,.50)); }

/* spacer row between fret0 and fret1 */
.spacer{
  height: var(--spacerH);
  background: rgba(255,255,255,.04);
  border-bottom:1px solid rgba(255,255,255,.10);
}
.spacer.left{ border-right:1px solid rgba(255,255,255,.18); }

/* pulse */
@keyframes pulseGlow{
  0%   { box-shadow: inset 0 0 0 2px rgba(255,255,255,.20), 0 0 0 rgba(255,255,255,0); }
  40%  { box-shadow: inset 0 0 0 2px rgba(255,255,255,.62), 0 0 30px rgba(255,255,255,.45); }
  100% { box-shadow: inset 0 0 0 2px rgba(255,255,255,.35), 0 0 18px rgba(255,255,255,.22); }
}
.cell.pulse{ animation: pulseGlow .45s ease-out; }

/* pos marks */
.cell .posmark{
  position:absolute;
  width:9px; height:9px;
  border-radius:50%;
  background: rgba(255,255,255,.95);
  right:7px;
  top:7px;
  box-shadow: var(--glow);
}
.cell.double::after{
  content:"";
  position:absolute;
  width:9px; height:9px;
  border-radius:50%;
  background: rgba(255,255,255,.95);
  right:20px;
  top:7px;
  box-shadow: var(--glow);
}

/* piano */
.piano{
  width:var(--pW);
  height: 100%;
  position:relative;
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.22);
  border-radius:16px;
  overflow:hidden;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12), 0 0 24px rgba(255,255,255,.06);
}
.key-white{
  position:absolute;
  left:0;
  width:var(--pW);
  height:var(--whiteH);
  border-top:1px solid rgba(255,255,255,.16);
  display:flex;
  align-items:center;
  justify-content:flex-end;
  padding-right:8px;
  font-weight:1000;
  font-size:12px;
  color: rgba(255,255,255,.90);
  background: rgba(255,255,255,.06);
}
.key-black{
  position:absolute;
  left:0;
  width:var(--blackW);
  height:var(--blackH);
  background: rgba(0,0,0,.95);
  border:1px solid rgba(255,255,255,.34);
  border-radius:6px;
  z-index:3;
  display:flex;
  align-items:center;
  justify-content:flex-end;
  padding-right:6px;
  font-weight:1000;
  font-size:11px;
  color: rgba(255,255,255,.96);
  box-shadow: 0 2px 14px rgba(0,0,0,.75);
}
.key-white.active{
  background: rgba(255,255,255,.20);
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.25), var(--glow);
}
.key-black.active{
  background: rgba(255,255,255,.75);
  color:#111;
  border-color: rgba(255,255,255,.70);
  box-shadow: var(--glowStrong);
}

/* right */
.right-col{ display:flex; flex-direction:column; gap:14px; min-width: 420px; max-width: 640px; }
.chordlist{ max-height: 74vh; overflow:auto; padding-right:6px; }
.chordlist::-webkit-scrollbar{ width:10px; }
.chordlist::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.22);
  border-radius:999px;
  border:2px solid rgba(0,0,0,.55);
}
.chordgrid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }
.cbtn{
  border:1px solid rgba(255,255,255,.20);
  background: rgba(0,0,0,.35);
  color:#fff;
  padding:10px 8px;
  border-radius:14px;
  font-weight:1000;
  font-size:14px;
  cursor:pointer;
  transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
  touch-action: manipulation;
}
.cbtn:hover{ border-color: rgba(255,255,255,.55); box-shadow: var(--glow); }
.cbtn:active{ transform: translateY(1px); }
.cbtn[disabled]{ opacity:.35; cursor:not-allowed; }

.badge{
  display:inline-block;
  margin-left:6px;
  font-size:12px;
  font-weight:1000;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.28);
  background: rgba(255,255,255,.08);
}
.badge.ok{ box-shadow: 0 0 14px rgba(255,255,255,.35); }
.badge.ng{ opacity:.7; }

/* ======== Mobile optimization ======== */
@media (max-width: 900px){
  :root{
    --cellW: 44px;
    --cellH: 40px;
    --fretW: 52px;
    --spacerH: 40px;
    --pW: 170px;
    --stepH: 15px;
    --whiteH: 15px;
    --blackH: 12px;
    --blackW: 128px;
    --xW: 62px;
  }
  .wrap{ padding: 10px; }
  h1{ font-size:20px; }
  select, .btn, input, label{ font-size:15px; padding:12px 12px; border-radius:16px; }
  .panel-title{ font-size:14px; }
  .xbtn .x{ font-size:20px; }
  .xbtn .lbl{ font-size:13px; }
}

@media (max-width: 720px){
  /* stack panels vertically (avoid sideways scroll for mobile) */
  .main{
    flex-direction: column;
    overflow-x: visible;
  }
  .right-col{
    min-width: unset;
    max-width: unset;
    width: 100%;
  }
  .panel{ width:100%; }
  .fret-piano{ gap:10px; }
  .chordgrid{ grid-template-columns: repeat(2, 1fr); }
  .cbtn{ padding:14px 10px; font-size:16px; border-radius:18px; }
  .scroll{ max-height: 62vh; }
}

@media (max-width: 420px){
  :root{
    --cellW: 46px;
    --cellH: 44px;
    --fretW: 56px;
    --xW: 66px;
  }
  .chordgrid{ grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="wrap">

  <div class="header">
    <h1>ギター／ベースピアノ変換サイト</h1>
    <div class="controls">
      <select id="instSel" title="楽器">
        <option value="guitar">ギター（6弦）</option>
        <option value="bass4">ベース（4弦）</option>
        <option value="bass5">ベース（5弦）</option>
        <option value="bass6">ベース（6弦）</option>
      </select>

      <select id="tuneSel" title="チューニング">
        <option value="0">標準</option>
        <option value="-1">半音下げ</option>
        <option value="-2">全音下げ</option>
      </select>

      <select id="capoSel" title="仮想カポ（ギターのみ）"></select>

      <select id="voicingSel" title="押さえ方（一般的）">
        <option value="open">OPEN優先</option>
        <option value="barreE">Eフォーム優先</option>
        <option value="barreA">Aフォーム優先</option>
      </select>

      <select id="powerRootSel" title="パワーコード(5) ルート弦（ギター）">
        <option value="auto">Power: 自動</option>
        <option value="6">Power: 6弦ルート</option>
        <option value="5">Power: 5弦ルート</option>
      </select>

      <label class="toggle" title="オンコードモード（例: C/E）">
        <input id="slashMode" type="checkbox">
        <span>オンコード</span>
      </label>

      <select id="bassNoteSel" title="オンコードのベース音" style="display:none;"></select>
      <select id="bassFollowSel" title="ベース：ルート追従する弦" style="display:none;"></select>

      <button class="btn" id="btnShare" type="button" title="URLをコピー">共有URL</button>
      <button class="btn" id="btnClear" type="button">クリア</button>
    </div>
  </div>

  <div class="main">
    <!-- left -->
    <div class="panel">
      <div class="panel-title">指板（0〜22 / 縦スクロール） + ピアノロール（無音表示）</div>
      <div class="panel-body fret-piano">

        <div>
          <div class="mute-strip" id="muteStrip">
            <div class="mute-x" id="muteX">X</div>
          </div>

          <div class="headerwrap">
            <div class="strings-row" id="stringsRow"></div>
            <div class="xcol" id="xColHeader"></div>
          </div>

          <div class="scroll" id="scrollArea">
            <div class="fretwrap">
              <div class="board" id="board"></div>
              <div class="xcol xcol-sticky" id="xColSticky"></div>
            </div>
          </div>
        </div>

        <div class="piano" id="piano"></div>

      </div>
    </div>

    <!-- right -->
    <div class="right-col">
      <div class="panel">
        <div class="panel-title">コード一覧（一般的な押さえ方のみ / 押さえられないものは非表示）</div>
        <div class="panel-body">
          <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
            <input id="searchBox" placeholder="検索 (例: C5, C#dim, Bb7, C/E)" style="flex:1; min-width:220px;">
            <select id="qualitySel" title="絞り込み"></select>
          </div>
          <div style="margin-top:10px; color:rgba(255,255,255,.88); font-weight:900; font-size:13px;">
            指板セル：クリックで入力 / 同じ場所クリックでミュート<br>
            右の <b>X</b>：弦ごとミュート切替（発光＝ミュート）<br>
            コード：クリックで自動入力 / ダブルクリックで解除（ベースは<b>ルートのみ</b>）<br>
            共有：右上「共有URL」で状態つきURLコピー
          </div>
          <div class="chordlist" style="margin-top:10px;">
            <div class="chordgrid" id="chordGrid"></div>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* ===================== CONFIG ===================== */
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const BLACK_PCS = new Set([1,3,6,8,10]);
const FRETS = 22;

// Piano range: include low B0 for bass 5/6
const MIN_MIDI = 23; // B0
const MAX_MIDI = 84; // C6

// Tunings (MIDI open strings)
const GUITAR_6 = {6:40,5:45,4:50,3:55,2:59,1:64};
const BASS_4   = {4:28,3:33,2:38,1:43};
const BASS_5   = {5:23,4:28,3:33,2:38,1:43};
const BASS_6   = {6:23,5:28,4:33,3:38,2:43,1:48};

const ALL_COLS = [6,5,4,3,2,1];

/* ===================== HELPERS ===================== */
const mod = (n,m)=>((n%m)+m)%m;
const isBlack = (m)=>BLACK_PCS.has(m%12);
const pcToName = (pc)=>NOTE_NAMES[mod(pc,12)];
const nameToPc = (name)=>NOTE_NAMES.indexOf(name);
const midiToName = (midi)=>{
  const n = NOTE_NAMES[midi%12];
  const oct = Math.floor(midi/12)-1;
  return `${n}${oct}`;
};
const midiToFreq = (midi)=>440*Math.pow(2,(midi-69)/12);

/* ===================== STATE ===================== */
let instrument = "guitar"; // guitar|bass4|bass5|bass6
let tuneOffset = 0;        // 0|-1|-2
let capo = 0;              // 0..12 (guitar only)
let voicingPref = "open";  // open|barreE|barreA
let slashMode = false;
let slashBassPc = nameToPc("E");
let powerRootPref = "auto"; // auto|"6"|"5"
let bassFollowString = 6;

let baseTuning = structuredClone(GUITAR_6);
let activeStrings = [6,5,4,3,2,1];

// per string: fret number or null=mute
const selectedByString = new Map();
function resetSelected(){
  selectedByString.clear();
  ALL_COLS.forEach(s=>selectedByString.set(s,null));
}
resetSelected();

/* ============ URL state (hash) ============ */
let saveTimer = null;
function scheduleSave(){
  clearTimeout(saveTimer);
  saveTimer = setTimeout(saveStateToHash, 120);
}
function saveStateToHash(){
  const params = new URLSearchParams();
  params.set("i", instrument);
  params.set("t", String(tuneOffset));
  params.set("c", String(capo));
  params.set("v", voicingPref);
  params.set("p", powerRootPref);
  params.set("s", slashMode ? "1":"0");
  params.set("b", pcToName(slashBassPc));
  params.set("bf", String(bassFollowString));

  const parts = [];
  for(const s of ALL_COLS){
    if(!activeStrings.includes(s)) continue;
    const f = selectedByString.get(s);
    parts.push(`${s}:${f===null?"x":f}`);
  }
  params.set("pos", parts.join("|"));

  const newHash = "#" + params.toString();
  if(location.hash !== newHash){
    history.replaceState(null, "", newHash);
  }
}
function loadStateFromHash(){
  if(!location.hash || location.hash.length<2) return false;
  const raw = location.hash.slice(1);
  const params = new URLSearchParams(raw);

  const i = params.get("i"); if(i) instrument = i;
  const t = params.get("t"); if(t!==null && t!=="") tuneOffset = Number(t);
  const c = params.get("c"); if(c!==null && c!=="") capo = Number(c);
  const v = params.get("v"); if(v) voicingPref = v;
  const p = params.get("p"); if(p) powerRootPref = p;
  const s = params.get("s"); if(s) slashMode = (s==="1");
  const b = params.get("b"); if(b && NOTE_NAMES.includes(b)) slashBassPc = nameToPc(b);
  const bf = params.get("bf"); if(bf!==null && bf!=="") bassFollowString = Number(bf);

  const pos = params.get("pos");
  if(pos){
    resetSelected();
    const pairs = pos.split("|").map(x=>x.trim()).filter(Boolean);
    for(const pr of pairs){
      const [ss, ff] = pr.split(":");
      const sNum = Number(ss);
      if(!Number.isFinite(sNum)) continue;
      if(ff==="x"){
        selectedByString.set(sNum, null);
      }else{
        const fNum = Number(ff);
        if(Number.isFinite(fNum)) selectedByString.set(sNum, fNum);
      }
    }
  }
  return true;
}

/* ===================== AUDIO (POKO) ===================== */
let audioCtx = null;
function getCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  return audioCtx;
}
function poko(freq, duration=0.12){
  const ctx = getCtx();
  const now = ctx.currentTime;

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  const filt = ctx.createBiquadFilter();

  osc.type = "sine";
  osc.frequency.setValueAtTime(freq*1.6, now);
  osc.frequency.exponentialRampToValueAtTime(freq, now + 0.04);

  filt.type = "lowpass";
  filt.frequency.setValueAtTime(Math.min(5200, freq*8), now);
  filt.Q.setValueAtTime(0.8, now);

  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.9, now + 0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

  osc.connect(filt); filt.connect(gain); gain.connect(ctx.destination);
  osc.start(now);
  osc.stop(now + duration + 0.02);
}

/* ===================== TUNING ===================== */
function currentTuning(){
  const t = {};
  const capoOffset = (instrument==="guitar") ? capo : 0;
  for(const s of activeStrings){
    t[s] = baseTuning[s] + tuneOffset + capoOffset;
  }
  return t;
}

/* ===================== UI BUILDERS ===================== */
function pulseCell(cell){
  cell.classList.remove('pulse'); void cell.offsetWidth; cell.classList.add('pulse');
}

function buildCapoSel(){
  const sel = document.getElementById('capoSel');
  sel.innerHTML = "";
  const opt0 = document.createElement('option');
  opt0.value = "0"; opt0.textContent = "カポなし";
  sel.appendChild(opt0);
  for(let i=1;i<=12;i++){
    const o = document.createElement('option');
    o.value = String(i); o.textContent = `カポ${i}`;
    sel.appendChild(o);
  }
}

function buildQualitySel(){
  const sel = document.getElementById('qualitySel');
  sel.innerHTML = "";
  const o0 = document.createElement('option');
  o0.value="all"; o0.textContent="すべて";
  sel.appendChild(o0);
  QUALITIES.forEach(q=>{
    const o=document.createElement('option');
    o.value=q.id; o.textContent=q.id;
    sel.appendChild(o);
  });
}

function buildBassNoteSel(){
  const sel = document.getElementById('bassNoteSel');
  sel.innerHTML="";
  NOTE_NAMES.forEach(n=>{
    const o=document.createElement('option');
    o.value=n; o.textContent=n;
    sel.appendChild(o);
  });
}

function repopulateBassFollowSel(){
  const sel = document.getElementById('bassFollowSel');
  sel.innerHTML = "";
  const strings = [...activeStrings].sort((a,b)=>b-a);
  strings.forEach(s=>{
    const o=document.createElement('option');
    o.value=String(s);
    o.textContent=`${s}弦でルート`;
    sel.appendChild(o);
  });
}

function buildStringsHeaderAndX(){
  const row = document.getElementById('stringsRow');
  row.innerHTML = "";

  // left blank cell
  const left = document.createElement('div');
  left.textContent = "";
  row.appendChild(left);

  const tuning = currentTuning();
  for(const s of ALL_COLS){
    const wrap = document.createElement('div');
    wrap.className = "slabwrap";
    wrap.id = `slw${s}`;

    const open = document.createElement('div');
    open.className = "openname";
    open.id = `open${s}`;
    open.textContent = activeStrings.includes(s) ? midiToName(tuning[s]) : "—";

    const slab = document.createElement('div');
    slab.className = "slab";
    slab.textContent = `${s}`;

    wrap.appendChild(open);
    wrap.appendChild(slab);
    row.appendChild(wrap);
  }

  // build X buttons (header + sticky)
  const h = document.getElementById('xColHeader');
  const st = document.getElementById('xColSticky');
  h.innerHTML = "";
  st.innerHTML = "";
  for(const s of ALL_COLS){
    const make = (idPrefix)=>{
      const btn = document.createElement('div');
      btn.className = "xbtn";
      btn.id = `${idPrefix}${s}`;
      btn.dataset.string = String(s);

      const x = document.createElement('div');
      x.className = "x";
      x.textContent = "X";
      const lbl = document.createElement('div');
      lbl.className = "lbl";
      lbl.textContent = `${s}弦`;

      btn.appendChild(x);
      btn.appendChild(lbl);
      return btn;
    };
    h.appendChild(make("xH"));
    st.appendChild(make("xS"));
  }
}

function buildBoard(){
  const board = document.getElementById('board');
  board.innerHTML = "";

  // fret 0 row
  const fret0 = document.createElement('div');
  fret0.className = "fret openrow";
  fret0.textContent = "0";
  board.appendChild(fret0);

  for(const s of ALL_COLS){
    const c = document.createElement('div');
    c.className = "cell openrow";
    c.dataset.string = String(s);
    c.dataset.fret = "0";
    board.appendChild(c);
  }

  // spacer row
  const spL = document.createElement('div');
  spL.className = "spacer left";
  board.appendChild(spL);
  for(let i=0;i<6;i++){
    const sp = document.createElement('div');
    sp.className="spacer";
    board.appendChild(sp);
  }

  // frets 1..22
  const dotFrets = new Set([3,5,7,9,15,17,19,21]);
  for(let f=1; f<=FRETS; f++){
    const fr = document.createElement('div');
    fr.className="fret";
    fr.textContent=String(f);
    board.appendChild(fr);

    for(const s of ALL_COLS){
      const cell = document.createElement('div');
      cell.className = "cell";
      cell.dataset.string = String(s);
      cell.dataset.fret = String(f);

      if(f===12) cell.classList.add('double');
      if(dotFrets.has(f)){
        const pm=document.createElement('span');
        pm.className="posmark";
        cell.appendChild(pm);
      }
      board.appendChild(cell);
    }
  }
}

function buildPiano(){
  const piano = document.getElementById('piano');
  piano.innerHTML = "";

  const stepH  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stepH'));
  const whiteH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--whiteH'));
  const blackH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--blackH'));

  const total = (MAX_MIDI - MIN_MIDI + 1) * stepH;
  piano.style.height = `${total}px`;

  for(let midi=MIN_MIDI; midi<=MAX_MIDI; midi++){
    const y = (midi - MIN_MIDI) * stepH;
    if(!isBlack(midi)){
      const w=document.createElement('div');
      w.className="key-white";
      w.id=`key${midi}`;
      w.style.bottom = `${y}px`;
      w.style.height = `${whiteH}px`;
      w.textContent = midiToName(midi);
      piano.appendChild(w);
    }else{
      const b=document.createElement('div');
      b.className="key-black";
      b.id=`key${midi}`;
      b.style.bottom = `${y + (whiteH-blackH)/2}px`;
      b.textContent = midiToName(midi);
      piano.appendChild(b);
    }
  }
}

/* ===================== UI UPDATE ===================== */
function clearPianoActive(){
  for(let midi=MIN_MIDI; midi<=MAX_MIDI; midi++){
    const el=document.getElementById(`key${midi}`);
    if(el) el.classList.remove('active');
  }
}
function getSelectedMidis(){
  const tuning=currentTuning();
  const midis=[];
  for(const s of ALL_COLS){
    const f=selectedByString.get(s);
    if(f===null) continue;
    if(!activeStrings.includes(s)) continue;
    const m = tuning[s] + f;
    if(m<MIN_MIDI || m>MAX_MIDI) continue;
    midis.push(m);
  }
  return Array.from(new Set(midis)).sort((a,b)=>a-b);
}
function updateMuteDots(){
  const strip=document.getElementById('muteStrip');
  const muteX=document.getElementById('muteX');
  strip.querySelectorAll('.dot').forEach(d=>d.remove());

  let anyMuted=false;
  for(const s of ALL_COLS){
    const d=document.createElement('div');
    const active = activeStrings.includes(s);
    const muted = active && selectedByString.get(s)===null;
    const on = active && !muted;
    if(muted) anyMuted=true;
    d.className = 'dot' + (on?' on':'') + (muted?' mutedGlow':'');
    strip.appendChild(d);
  }
  if(anyMuted) muteX.classList.add('glow'); else muteX.classList.remove('glow');
}
function updateOpenNamesAndHeader(){
  const tuning=currentTuning();
  for(const s of ALL_COLS){
    const wrap=document.getElementById(`slw${s}`);
    const open=document.getElementById(`open${s}`);
    if(!wrap || !open) continue;

    if(!activeStrings.includes(s)){
      wrap.classList.add('disabled');
      wrap.classList.remove('muted','mutedGlow');
      open.textContent="—";
      continue;
    }
    wrap.classList.remove('disabled');
    open.textContent = midiToName(tuning[s]);

    if(selectedByString.get(s)===null){
      wrap.classList.add('muted','mutedGlow');
    }else{
      wrap.classList.remove('muted','mutedGlow');
    }
  }
}
function syncBoardMutedCols(){
  document.querySelectorAll('.cell').forEach(cell=>{
    const s=Number(cell.dataset.string);
    if(!activeStrings.includes(s)){
      cell.classList.add('disabled');
      cell.classList.remove('mutedcol');
      return;
    }
    cell.classList.remove('disabled');
    if(selectedByString.get(s)===null) cell.classList.add('mutedcol');
    else cell.classList.remove('mutedcol');
  });
}
function markSelectedCells(){
  document.querySelectorAll('.cell.selected').forEach(el=>el.classList.remove('selected'));
  for(const s of ALL_COLS){
    const f = selectedByString.get(s);
    if(f===null) continue;
    const cell=document.querySelector(`.cell[data-string="${s}"][data-fret="${f}"]`);
    if(cell) cell.classList.add('selected');
  }
}
function updateXButtons(){
  for(const s of ALL_COLS){
    const muted = (selectedByString.get(s) === null);
    const active = activeStrings.includes(s);

    const h=document.getElementById(`xH${s}`);
    const st=document.getElementById(`xS${s}`);
    [h,st].forEach(btn=>{
      if(!btn) return;
      if(!active){
        btn.classList.add('disabled');
        btn.classList.remove('on');
        return;
      }
      btn.classList.remove('disabled');
      if(muted) btn.classList.add('on'); else btn.classList.remove('on');
    });
  }
}

function updateUI(){
  updateMuteDots();
  updateOpenNamesAndHeader();
  syncBoardMutedCols();

  clearPianoActive();
  const midis=getSelectedMidis();
  for(const m of midis){
    const el=document.getElementById(`key${m}`);
    if(el) el.classList.add('active');
  }

  updateXButtons();
  scheduleSave();
}

/* ===================== CHORD ENGINE (COMMON SHAPES ONLY) ===================== */
const QUALITIES = [
  {id:"maj",  label:""},
  {id:"min",  label:"m"},
  {id:"5",    label:"5"},
  {id:"7",    label:"7"},
  {id:"maj7", label:"maj7"},
  {id:"m7",   label:"m7"},
  {id:"sus2", label:"sus2"},
  {id:"sus4", label:"sus4"},
  {id:"6",    label:"6"},
  {id:"add9", label:"add9"},
  {id:"dim",  label:"dim"},
];
const qualityLabel = (qid)=> (QUALITIES.find(x=>x.id===qid)?.label ?? "");

const OPEN_FORMS = {
  "C:maj":  {6:null,5:3,4:2,3:0,2:1,1:0},
  "D:maj":  {6:null,5:null,4:0,3:2,2:3,1:2},
  "E:maj":  {6:0,5:2,4:2,3:1,2:0,1:0},
  "G:maj":  {6:3,5:2,4:0,3:0,2:0,1:3},
  "A:maj":  {6:null,5:0,4:2,3:2,2:2,1:0},

  "A:min":  {6:null,5:0,4:2,3:2,2:1,1:0},
  "E:min":  {6:0,5:2,4:2,3:0,2:0,1:0},
  "D:min":  {6:null,5:null,4:0,3:2,2:3,1:1},

  "E:7":    {6:0,5:2,4:0,3:1,2:0,1:0},
  "A:7":    {6:null,5:0,4:2,3:0,2:2,1:0},
  "D:7":    {6:null,5:null,4:0,3:2,2:1,1:2},
  "G:7":    {6:3,5:2,4:0,3:0,2:0,1:1},

  "C:maj7": {6:null,5:3,4:2,3:0,2:0,1:0},
  "A:m7":   {6:null,5:0,4:2,3:0,2:1,1:0},
  "E:m7":   {6:0,5:2,4:0,3:0,2:0,1:0},

  "D:sus4": {6:null,5:null,4:0,3:2,2:3,1:3},
  "A:sus4": {6:null,5:0,4:2,3:2,2:3,1:0},
  "E:sus4": {6:0,5:2,4:2,3:2,2:0,1:0},

  "D:dim":  {6:null,5:null,4:0,3:1,2:0,1:1},
};

// barre templates (include power chord split by rootString)
const BARRE = [
  // E-family
  {family:"E", q:"maj",  rootString:6, offs:{6:0,5:2,4:2,3:1,2:0,1:0}},
  {family:"E", q:"min",  rootString:6, offs:{6:0,5:2,4:2,3:0,2:0,1:0}},
  {family:"E", q:"7",    rootString:6, offs:{6:0,5:2,4:0,3:1,2:0,1:0}},
  {family:"E", q:"maj7", rootString:6, offs:{6:0,5:2,4:1,3:1,2:0,1:0}},
  {family:"E", q:"m7",   rootString:6, offs:{6:0,5:2,4:0,3:0,2:0,1:0}},
  {family:"E", q:"sus4", rootString:6, offs:{6:0,5:2,4:2,3:2,2:0,1:0}},
  {family:"E", q:"sus2", rootString:6, offs:{6:0,5:2,4:2,3:4,2:0,1:0}},
  {family:"E", q:"6",    rootString:6, offs:{6:0,5:2,4:2,3:1,2:2,1:0}},
  {family:"E", q:"add9", rootString:6, offs:{6:0,5:2,4:2,3:1,2:0,1:2}},
  {family:"E", q:"dim",  rootString:6, offs:{6:0,5:1,4:2,3:0,2:2,1:0}},
  {family:"E", q:"5",    rootString:6, offs:{6:0,5:2,4:2,3:null,2:null,1:null}},

  // A-family
  {family:"A", q:"maj",  rootString:5, offs:{6:null,5:0,4:2,3:2,2:2,1:0}},
  {family:"A", q:"min",  rootString:5, offs:{6:null,5:0,4:2,3:2,2:1,1:0}},
  {family:"A", q:"7",    rootString:5, offs:{6:null,5:0,4:2,3:0,2:2,1:0}},
  {family:"A", q:"maj7", rootString:5, offs:{6:null,5:0,4:2,3:1,2:2,1:0}},
  {family:"A", q:"m7",   rootString:5, offs:{6:null,5:0,4:2,3:0,2:1,1:0}},
  {family:"A", q:"sus4", rootString:5, offs:{6:null,5:0,4:2,3:2,2:3,1:0}},
  {family:"A", q:"sus2", rootString:5, offs:{6:null,5:0,4:2,3:2,2:0,1:0}},
  {family:"A", q:"6",    rootString:5, offs:{6:null,5:0,4:2,3:2,2:2,1:2}},
  {family:"A", q:"add9", rootString:5, offs:{6:null,5:0,4:2,3:2,2:0,1:0}},
  {family:"A", q:"dim",  rootString:5, offs:{6:null,5:0,4:1,3:2,2:1,1:2}},
  {family:"A", q:"5",    rootString:5, offs:{6:null,5:0,4:2,3:2,2:null,1:null}},
];

function soundingRootPc(rootPc){
  const semis = (instrument==="guitar") ? (capo + tuneOffset) : tuneOffset;
  return mod(rootPc + semis, 12);
}
function chordName(rootPc, qid){
  return pcToName(soundingRootPc(rootPc)) + qualityLabel(qid);
}
function voicingFromOpenForm(form){
  const v = {};
  for(const s of ALL_COLS){
    const f = form[s];
    if(f===null || f===undefined) v[s]=null;
    else if(f===0) v[s]=0;
    else{
      const abs = capo + f;
      if(abs>FRETS) return null;
      v[s]=abs;
    }
  }
  return v;
}
function voicingFromBarre(shape, barreFret){
  const v = {};
  for(const s of ALL_COLS){
    const o = shape.offs[s];
    if(o===null || o===undefined) v[s]=null;
    else{
      const f = barreFret + o;
      if(f<0 || f>FRETS) return null;
      v[s]=f;
    }
  }
  return v;
}
function isPlayableCommon(voicing){
  const frets=[];
  let count=0;
  for(const s of ALL_COLS){
    const f=voicing[s];
    if(f===null) continue;
    count++; frets.push(f);
  }
  if(count<2) return false;
  const minF=Math.min(...frets), maxF=Math.max(...frets);
  if(maxF-minF>5) return false;
  if(minF>17) return false;
  return true;
}
function shapesForQuality(qid){
  if(qid!=="5") return BARRE.filter(s=>s.q===qid);
  if(powerRootPref==="6") return BARRE.filter(s=>s.q==="5" && s.rootString===6);
  if(powerRootPref==="5") return BARRE.filter(s=>s.q==="5" && s.rootString===5);
  return BARRE.filter(s=>s.q==="5");
}
function voicingLowestMidi(voicing){
  const tuning=currentTuning();
  let best=null;
  for(const s of ALL_COLS){
    const f=voicing[s];
    if(f===null) continue;
    const midi=tuning[s]+f;
    if(best===null || midi<best) best=midi;
  }
  return best;
}
function voicingBassPc(voicing){
  const m=voicingLowestMidi(voicing);
  return (m===null)?null:mod(m,12);
}
function generateCommonVoicings(rootPc, qid){
  if(instrument!=="guitar") return [];
  const tuning=currentTuning();
  const out=[];

  const openKey = `${pcToName(rootPc)}:${qid}`;
  if(OPEN_FORMS[openKey]){
    const v=voicingFromOpenForm(OPEN_FORMS[openKey]);
    if(v && isPlayableCommon(v)) out.push({voicing:v, tag:"open"});
  }

  const shapes=shapesForQuality(qid);
  for(const sh of shapes){
    const rs=sh.rootString;
    const openMidi=tuning[rs];
    for(let bf=0; bf<=FRETS; bf++){
      if(mod(openMidi+bf,12)!==rootPc) continue;
      const v=voicingFromBarre(sh,bf);
      if(!v) continue;
      if(!isPlayableCommon(v)) continue;
      out.push({voicing:v, tag:`barre-${sh.family}`});
    }
  }

  const seen=new Set();
  const uniq=[];
  for(const r of out){
    const sig=ALL_COLS.map(s=>(r.voicing[s]===null?"x":r.voicing[s])).join("-");
    if(seen.has(sig)) continue;
    seen.add(sig);
    uniq.push(r);
  }

  uniq.sort((a,b)=>{
    const ma=Math.min(...ALL_COLS.map(s=>a.voicing[s]).filter(x=>x!==null));
    const mb=Math.min(...ALL_COLS.map(s=>b.voicing[s]).filter(x=>x!==null));
    return ma-mb;
  });

  return uniq;
}
function pickPreferredVoicing(voicings){
  if(!voicings.length) return null;
  if(voicingPref==="open"){
    const o=voicings.find(v=>v.tag==="open");
    return o || voicings[0];
  }
  if(voicingPref==="barreE"){
    const e=voicings.find(v=>v.tag==="barre-E");
    return e || voicings[0];
  }
  if(voicingPref==="barreA"){
    const a=voicings.find(v=>v.tag==="barre-A");
    return a || voicings[0];
  }
  return voicings[0];
}

/* bass: apply root only on chosen follow string */
function applyBassRootOnly(rootPc){
  ALL_COLS.forEach(s=>selectedByString.set(s,null));
  markSelectedCells();

  if(!activeStrings.includes(bassFollowString)) return;
  const tuning=currentTuning();
  const s=bassFollowString;
  const openPc=mod(tuning[s],12);

  let f=mod(rootPc-openPc,12);
  if(f+12<=FRETS && f<=2) f+=12;
  if(f>FRETS) f=0;

  selectedByString.set(s,f);
  markSelectedCells();
  updateUI();
}

function applyVoicing(voicing){
  ALL_COLS.forEach(s=>selectedByString.set(s,null));
  markSelectedCells();
  if(!voicing){ updateUI(); return; }

  for(const s of ALL_COLS){
    const f=voicing[s];
    if(f===null) continue;
    selectedByString.set(s,f);
  }
  markSelectedCells();
  updateUI();
}

/* chord inventory + render */
let allChordItems=[]; // {rootPc,qid,voicings}
function rebuildChordInventory(){
  allChordItems=[];
  for(const q of QUALITIES){
    for(let r=0;r<12;r++){
      if(instrument==="guitar"){
        const voicings=generateCommonVoicings(r,q.id);
        if(!voicings.length) continue;
        allChordItems.push({rootPc:r,qid:q.id,voicings});
      }else{
        // show only if it exists in guitar common shapes (filter "impossible")
        const saved = {instrument, baseTuning, activeStrings, capo, powerRootPref};
        instrument="guitar"; baseTuning=structuredClone(GUITAR_6); activeStrings=[6,5,4,3,2,1]; capo=0; powerRootPref="auto";
        const voicings=generateCommonVoicings(r,q.id);
        instrument=saved.instrument; baseTuning=saved.baseTuning; activeStrings=saved.activeStrings; capo=saved.capo; powerRootPref=saved.powerRootPref;

        if(!voicings.length) continue;
        allChordItems.push({rootPc:r,qid:q.id,voicings:[]});
      }
    }
  }
}
function passesSearch(item, q){
  if(!q) return true;
  const s=q.toLowerCase().replace(/\s+/g,"");
  const base=chordName(item.rootPc,item.qid).toLowerCase();
  const slash=(base+`/${pcToName(slashBassPc)}`).toLowerCase();
  return base.includes(s) || slash.includes(s);
}
function renderChordGrid(){
  const grid=document.getElementById('chordGrid');
  grid.innerHTML="";

  const qText=document.getElementById('searchBox').value.trim();
  const qFilter=document.getElementById('qualitySel').value;

  let items=allChordItems
    .filter(it=>qFilter==="all" ? true : it.qid===qFilter)
    .filter(it=>passesSearch(it,qText))
    .sort((a,b)=>chordName(a.rootPc,a.qid).localeCompare(chordName(b.rootPc,b.qid)));

  for(const it of items){
    const btn=document.createElement('button');
    btn.className="cbtn";
    btn.type="button";

    const baseName=chordName(it.rootPc,it.qid);

    if(slashMode && instrument==="guitar"){
      const wanted=slashBassPc;
      const okVoicing = it.voicings.find(v=>voicingBassPc(v.voicing)===wanted);
      const isOk=!!okVoicing;
      btn.innerHTML = `${baseName}/${pcToName(wanted)} <span class="badge ${isOk?'ok':'ng'}">bass ${isOk?'ok':'NG'}</span>`;
      btn.onclick = ()=>{
        const picked = okVoicing || pickPreferredVoicing(it.voicings);
        applyVoicing(picked ? picked.voicing : null);
      };
    }else{
      btn.textContent=baseName;
      btn.onclick=()=>{
        if(instrument==="guitar"){
          const v=pickPreferredVoicing(it.voicings);
          applyVoicing(v ? v.voicing : null);
        }else{
          applyBassRootOnly(it.rootPc);
        }
      };
    }

    btn.ondblclick=()=>document.getElementById('btnClear').click();
    grid.appendChild(btn);
  }
}

/* ===================== EVENTS ===================== */
function setInstrument(val){
  instrument=val;

  if(instrument==="guitar"){
    baseTuning=structuredClone(GUITAR_6);
    activeStrings=[6,5,4,3,2,1];
  }else if(instrument==="bass4"){
    baseTuning=structuredClone(BASS_4);
    activeStrings=[4,3,2,1];
    capo=0;
  }else if(instrument==="bass5"){
    baseTuning=structuredClone(BASS_5);
    activeStrings=[5,4,3,2,1];
    capo=0;
  }else{
    baseTuning=structuredClone(BASS_6);
    activeStrings=[6,5,4,3,2,1];
    capo=0;
  }

  // enable/disable controls
  const capoSel=document.getElementById('capoSel');
  const voSel=document.getElementById('voicingSel');
  const slashToggle=document.getElementById('slashMode');
  const bassNoteSel=document.getElementById('bassNoteSel');
  const bassFollowSel=document.getElementById('bassFollowSel');
  const powerSel=document.getElementById('powerRootSel');

  if(instrument!=="guitar"){
    capoSel.disabled=true;
    voSel.disabled=true;
    slashToggle.disabled=true;
    bassNoteSel.style.display="none";
    powerSel.disabled=true;

    bassFollowSel.style.display="inline-block";
    repopulateBassFollowSel();
    bassFollowSel.value = String(bassFollowString);
  }else{
    capoSel.disabled=false;
    voSel.disabled=false;
    slashToggle.disabled=false;
    powerSel.disabled=false;

    bassFollowSel.style.display="none";
    bassNoteSel.style.display = slashMode ? "inline-block" : "none";
  }

  buildStringsHeaderAndX();
  rebuildChordInventory();
  renderChordGrid();
  markSelectedCells();
  updateUI();
}

// click: fret cells
document.addEventListener('click',(e)=>{
  const cell=e.target.closest('.cell');
  if(!cell) return;

  const s=Number(cell.dataset.string);
  const f=Number(cell.dataset.fret);
  if(!activeStrings.includes(s)) return;

  // clear other selection on the same string
  document.querySelectorAll(`.cell.selected[data-string="${s}"]`).forEach(el=>el.classList.remove('selected'));

  const cur=selectedByString.get(s);
  if(cur===f){
    // same => mute
    selectedByString.set(s,null);
  }else{
    selectedByString.set(s,f);
    cell.classList.add('selected');
    pulseCell(cell);

    const tuning=currentTuning();
    poko(midiToFreq(tuning[s]+f), 0.12);
  }
  updateUI();
});

// click: X buttons (header/sticky)
document.addEventListener('click',(e)=>{
  const xb = e.target.closest('.xbtn');
  if(!xb) return;
  const s = Number(xb.dataset.string);
  if(!activeStrings.includes(s)) return;

  const now = selectedByString.get(s);
  if(now === null){
    // unmute -> open string
    selectedByString.set(s, 0);
  }else{
    // mute
    selectedByString.set(s, null);
    document.querySelectorAll(`.cell.selected[data-string="${s}"]`).forEach(el=>el.classList.remove('selected'));
  }
  markSelectedCells();
  updateUI();
});

document.getElementById('btnClear').onclick=()=>{
  ALL_COLS.forEach(s=>selectedByString.set(s,null));
  markSelectedCells();
  updateUI();
};

document.getElementById('instSel').onchange=(e)=>{ setInstrument(e.target.value); scheduleSave(); };
document.getElementById('tuneSel').onchange=(e)=>{
  tuneOffset=Number(e.target.value);
  buildStringsHeaderAndX();
  rebuildChordInventory();
  renderChordGrid();
  updateUI();
};
document.getElementById('capoSel').onchange=(e)=>{
  capo=Number(e.target.value);
  if(instrument!=="guitar"){ capo=0; e.target.value="0"; }
  buildStringsHeaderAndX();
  rebuildChordInventory();
  renderChordGrid();
  updateUI();
};
document.getElementById('voicingSel').onchange=(e)=>{ voicingPref=e.target.value; scheduleSave(); };
document.getElementById('powerRootSel').onchange=(e)=>{
  powerRootPref=e.target.value;
  rebuildChordInventory();
  renderChordGrid();
  updateUI();
};
document.getElementById('searchBox').oninput=()=>renderChordGrid();
document.getElementById('qualitySel').onchange=()=>renderChordGrid();
document.getElementById('slashMode').onchange=(e)=>{
  slashMode=e.target.checked;
  const sel=document.getElementById('bassNoteSel');
  if(slashMode && instrument==="guitar") sel.style.display="inline-block";
  else sel.style.display="none";
  renderChordGrid();
  scheduleSave();
};
document.getElementById('bassNoteSel').onchange=(e)=>{
  slashBassPc=nameToPc(e.target.value);
  renderChordGrid();
  scheduleSave();
};
document.getElementById('bassFollowSel').onchange=(e)=>{
  bassFollowString=Number(e.target.value);
  scheduleSave();
};

document.getElementById('btnShare').onclick = async ()=>{
  saveStateToHash();
  const url = location.href;
  try{
    await navigator.clipboard.writeText(url);
    const btn = document.getElementById('btnShare');
    const old = btn.textContent;
    btn.textContent = "コピー済み";
    setTimeout(()=>btn.textContent=old, 900);
  }catch{
    prompt("このURLをコピーして共有してね", url);
  }
};

/* ===================== INIT ===================== */
function buildAllStatic(){
  buildCapoSel();
  buildQualitySel();
  buildBassNoteSel();
  buildPiano();
  buildBoard();
}

function applyStateToControls(){
  document.getElementById('instSel').value = instrument;
  document.getElementById('tuneSel').value = String(tuneOffset);
  document.getElementById('capoSel').value = String(capo);
  document.getElementById('voicingSel').value = voicingPref;
  document.getElementById('powerRootSel').value = powerRootPref;
  document.getElementById('slashMode').checked = slashMode;
  document.getElementById('bassNoteSel').value = pcToName(slashBassPc);
}

function init(){
  buildAllStatic();

  const had = loadStateFromHash();
  applyStateToControls();

  setInstrument(instrument);

  if(instrument!=="guitar"){
    repopulateBassFollowSel();
    document.getElementById('bassFollowSel').value = String(bassFollowString);
  }

  markSelectedCells();
  updateUI();

  if(!had) saveStateToHash();
}
init();
</script>
</body>
</html>
